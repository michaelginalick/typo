<!DOCTYPE html>
<html lang="en-us"
  dir="ltr">

  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width"><meta name="description" content="Classic design pattern in Go" />

<title>
    
    Command Pattern Revisited | Me
    
</title>

<link rel="canonical" href="https://michaelginalick.com/posts/command-pattern-revisited/" />












<link rel="stylesheet" href="/assets/combined.min.a6824bbee0d90d5af09fed9b70395ce7076b615e315037455d903314e96ef91b.css" media="all">






  </head>

  

  
  
  

  <body class="auto">

    <div class="content">
      <header>
        

<div class="header">

    

    <h1 class="header-title">Me</h1>

    <div class="flex">
        

        
        
        <p class="small ">
            <a href="/">
                /home
            </a>
        </p>
        
        <p class="small ">
            <a href="/posts">
                /posts
            </a>
        </p>
        
        <p class="small ">
            <a href="/about">
                /about
            </a>
        </p>
        
        
    </div>

    

</div>
      </header>

      <main class="main">
        




<div class="breadcrumbs">
    
    <a href="/">Home</a>
    <span class="breadcrumbs-separator"> > </span>
    
    <a href="/posts/">Posts</a>
    <span class="breadcrumbs-separator"> > </span>
    
    <a class="breadcrumbs-current" href="/posts/command-pattern-revisited/">Command Pattern Revisited</a>
</div>


<div  class="autonumber" >

  <div class="single-intro-container">

    

    <h1 class="single-title">Command Pattern Revisited</h1>
    
    <p class="single-summary">An update to a previous post</p>
    

    

    <p class="single-readtime">
      
      
      
      <time datetime="2025-12-09T16:34:06-06:00">December 9, 2025</time>
      

      
      &nbsp; · &nbsp;
      7 min read
      
    </p>

  </div>

  

  
  

  <div class="single-tags">
    
    <span>
      <a href="https://michaelginalick.com/tags/go/">#Go</a>
    </span>
    
    
    <span>
      <a href="https://michaelginalick.com/tags/design-patterns/">#Design Patterns</a>
    </span>
    
    
    <span>
      <a href="https://michaelginalick.com/tags/command-pattern/">#Command Pattern</a>
    </span>
    
    
    <span>
      <a href="https://michaelginalick.com/tags/first-class-functions/">#First Class Functions</a>
    </span>
    
    
  </div>

  
  

  

  

  

  <div class="single-content">
    <p>Turns out Go developers don&rsquo;t like the classic design patterns presented in the <a href="https://en.wikipedia.org/wiki/Design_Patterns">Gang of Four</a>. While I&rsquo;m not positive, I think it&rsquo;s because of the full name: &ldquo;Design Patterns: Elements of Reusable Object-Oriented Software&rdquo;. The &ldquo;Object-Oriented&rdquo; part is what gives some Go developers a hard pass. Go is not object oriented. That much is difficult to dispute. It does however present users with object oriented constructs such as this:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">type</span> User <span style="color:#fff;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    FirstName <span style="color:#fff;font-weight:bold">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">func</span> (u *User) ModifyFirstName(firstName <span style="color:#fff;font-weight:bold">string</span>) {
</span></span><span style="display:flex;"><span>    u.FirstName = firstName
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Or for example you can create a getter function (although its not necessary (or even common)) like so</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">func</span> (u User) ReadFirstName(firstName <span style="color:#fff;font-weight:bold">string</span>) <span style="color:#fff;font-weight:bold">string</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> u.FirstName
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Notice the lack of a pointer in the signature. This tells the reader that this method does not modify the instance. Reguardless, User is not a class. Getting an instance of it doesn&rsquo;t require a specific constructor. You can create one like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span>    u := &amp;User{}
</span></span></code></pre></div><p>or like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span>    u : &amp;User{FirstName: <span style="color:#0ff;font-weight:bold">&#34;Mike&#34;</span>}
</span></span></code></pre></div><p>You can even do this:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">func</span> NewUser(fName <span style="color:#fff;font-weight:bold">string</span>) *User {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">return</span> &amp;User{
</span></span><span style="display:flex;"><span>            FirstName: fname
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>These are all functionality equivilant. Note there is a <code>new</code> keyword, but it is rarely used and is syntatic sugar. These are the same.</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span>    u := <span style="color:#fff;font-weight:bold">new</span>(User)
</span></span><span style="display:flex;"><span>    uu := &amp;User{}
</span></span></code></pre></div><p>The point is: Go is not object-oriented, but that doesn’t mean anything from OOP is bad, useless or doesn&rsquo;t belong in Go. More importantly, it doesn’t mean that concepts from other paradigms have nothing to teach. Design patterns are and will always be extremely valuable — if nothing else, they provide a shared vocabulary for discussing solutions. I’m not saying you should force every problem into a pattern. But having a conceptual understanding of common patterns is useful.</p>
<p>This common language came up recently on a project at work. I will spare a lot of the details since they won&rsquo;t make any sense to anyone not familiar with this exact system. At a high level, there is of files. You can think of them like rules and you want to run a process against a specific set of rules. However, all the rules need to be backwards compatible so if you create a version 2 of an existing rule set, version 2 must be able to execute version 1. In the end anytime you create a new set of these versioned rules, you basically create a new file, copy and paste the existing version of the rule set into the new file, then add whatever changes you need in this new versioned file. One caveat is that in the individual rule files, there are unique identifiers, and they often refer to that particular version. When creating a new version you must go through and update these identifiers to be the new version. Make sense? Probably not, but that&rsquo;s ok.</p>
<p>After creating a few of these new file versions a team member suggested we make a tool that does this for us. Great idea!
The first version was pretty simple, but as more functionality was added the code became a bit cumbersome and difficult to understand. A refactor was in order and I had an idea on how things could be organized.</p>
<p>The tool was running a series of steps. If any one step failed, then the program would exit. It didn&rsquo;t need to concern itself with things like cleanup. To me, this was a use case for a flavor of the command pattern. The implementation was fairly straightforward. It looks something like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">type</span> Action <span style="color:#fff;font-weight:bold">int</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">const</span> (
</span></span><span style="display:flex;"><span>	ReadInFile Action = <span style="color:#fff;font-weight:bold">iota</span>
</span></span><span style="display:flex;"><span>	TransFormContents
</span></span><span style="display:flex;"><span>	WriteNewFile
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">type</span> Command <span style="color:#fff;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>	action Action
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">type</span> Commands <span style="color:#fff;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>	commands []Command
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">type</span> FileModificationCommand <span style="color:#fff;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>	Commands
</span></span><span style="display:flex;"><span>	name <span style="color:#fff;font-weight:bold">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">func</span> (f *FileModificationCommand) Call() <span style="color:#fff;font-weight:bold">error</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">for</span> _, cmd := <span style="color:#fff;font-weight:bold">range</span> f.commands {
</span></span><span style="display:flex;"><span>		cmd.Call()
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">func</span> NewFileCommand(action Action) Command {
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">return</span> Command{action: action}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">func</span> (c *Command) Read() {
</span></span><span style="display:flex;"><span>	fmt.Println(<span style="color:#0ff;font-weight:bold">&#34;Read&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">func</span> (c *Command) TransFormContents() {
</span></span><span style="display:flex;"><span>	fmt.Println(<span style="color:#0ff;font-weight:bold">&#34;Transform&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">func</span> (c *Command) Write() {
</span></span><span style="display:flex;"><span>	fmt.Println(<span style="color:#0ff;font-weight:bold">&#34;Write&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">func</span> (c *Command) Call() {
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">switch</span> c.action {
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">case</span> ReadInFile:
</span></span><span style="display:flex;"><span>		c.Read()
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">case</span> TransFormContents:
</span></span><span style="display:flex;"><span>		c.TransFormContents()
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">case</span> WriteNewFile:
</span></span><span style="display:flex;"><span>		c.Write()
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">func</span> NewCommand() *FileModificationCommand {
</span></span><span style="display:flex;"><span>	fc := &amp;FileModificationCommand{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	fc.commands = <span style="color:#fff;font-weight:bold">append</span>(fc.commands,
</span></span><span style="display:flex;"><span>		NewFileCommand(ReadInFile),
</span></span><span style="display:flex;"><span>		NewFileCommand(TransFormContents),
</span></span><span style="display:flex;"><span>		NewFileCommand(WriteNewFile),
</span></span><span style="display:flex;"><span>	)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">return</span> fc
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">func</span> main() {
</span></span><span style="display:flex;"><span>	f := NewCommand()
</span></span><span style="display:flex;"><span>	f.Call()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This is a high level version of what was submitted. To be completely honest I was feeling pretty good about how it turned out. While I didn&rsquo;t explicitly say I used the command pattern, it was pretty evident from the naming convention.</p>
<p>The implementation generated many comments, some negative, revolving mostly around how this implementation is too OOP and not idiomatic Go. Other comments were much more helpful. These comments took note of all the boiler plate - specifically these sections:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">type</span> Action <span style="color:#fff;font-weight:bold">int</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">const</span> (
</span></span><span style="display:flex;"><span>    ReadInFile Action = <span style="color:#fff;font-weight:bold">iota</span>
</span></span><span style="display:flex;"><span>    TransFormContents
</span></span><span style="display:flex;"><span>    WriteNewFile
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">func</span> (c *Command) Call() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">switch</span> c.action {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">case</span> ReadInFile:
</span></span><span style="display:flex;"><span>            c.Read()
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">case</span> TransFormContents:
</span></span><span style="display:flex;"><span>            c.Transform()
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">case</span> Write:
</span></span><span style="display:flex;"><span>            c.Write()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The primary issue the commenter called out was the <code>Action</code> (Go&rsquo;s version of an Emun) and <code>Call</code> function. This function looks at the command&rsquo;s <code>Action</code> and calls the appropriate method. This implementation is completely unnecessary since Go has first class functions. Instead of associating an <code>Action</code> with a method, you can simply call the function. This is great feedback. With it, the code can look something like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-golang" data-lang="golang"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">type</span> FileModificationCommand <span style="color:#fff;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>	Commands []*Command
</span></span><span style="display:flex;"><span>	name     <span style="color:#fff;font-weight:bold">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">type</span> cmd <span style="color:#fff;font-weight:bold">func</span>() <span style="color:#fff;font-weight:bold">error</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">type</span> Command <span style="color:#fff;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>	fn cmd
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">func</span> (f *FileModificationCommand) Call() <span style="color:#fff;font-weight:bold">error</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">for</span> _, cmd := <span style="color:#fff;font-weight:bold">range</span> f.Commands {
</span></span><span style="display:flex;"><span>		<span style="color:#fff;font-weight:bold">if</span> err := cmd.fn(); err != <span style="color:#fff;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#fff;font-weight:bold">return</span> err
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">func</span> NewFileCommand(f cmd) *Command {
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">return</span> &amp;Command{fn: f}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">func</span> Read() <span style="color:#fff;font-weight:bold">error</span> {
</span></span><span style="display:flex;"><span>	fmt.Println(<span style="color:#0ff;font-weight:bold">&#34;READ&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">func</span> TransFormContents() <span style="color:#fff;font-weight:bold">error</span> {
</span></span><span style="display:flex;"><span>	fmt.Println(<span style="color:#0ff;font-weight:bold">&#34;TRANSFORM&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">func</span> Write() <span style="color:#fff;font-weight:bold">error</span> {
</span></span><span style="display:flex;"><span>	fmt.Println(<span style="color:#0ff;font-weight:bold">&#34;WRITE&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">func</span> NewCommand() *FileModificationCommand {
</span></span><span style="display:flex;"><span>	fc := &amp;FileModificationCommand{}
</span></span><span style="display:flex;"><span>	fc.Commands = <span style="color:#fff;font-weight:bold">append</span>(fc.Commands, NewFileCommand(Read))
</span></span><span style="display:flex;"><span>	fc.Commands = <span style="color:#fff;font-weight:bold">append</span>(fc.Commands, NewFileCommand(TransFormContents))
</span></span><span style="display:flex;"><span>	fc.Commands = <span style="color:#fff;font-weight:bold">append</span>(fc.Commands, NewFileCommand(Write))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">return</span> fc
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">func</span> main() {
</span></span><span style="display:flex;"><span>	f := NewCommand()
</span></span><span style="display:flex;"><span>	f.Call()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This implementation, while it doesn&rsquo;t move away from the usage of the pattern (by design), is much more idiomatic. It doesn&rsquo;t require the boilerplate that decides which method to call based on a given <code>Action</code>. It doesn&rsquo;t require an <code>Action</code> at all. This is very good in my opinion. There is less code, and less indirection. Functions are able to be defined, passed around, and directly envoked in an extendable pattern.</p>
<p>Aside from the final code being an overall better implementation, what I really enjoyed was the conversation around the usage of the pattern. It appeared evident that team members who knew the pattern had a lot to say. I believe that is because we were all converging around a common language. They knew the pattern, saw what I was trying to do, and offered great feedback and a better way to do it.</p>
<p>People argue all the time about these kinds of classical design patterns and whether or not they are relevant. Some claim you don&rsquo;t need them as they are not necessary. Personally, I think that is the wrong approach. Yes, knowing the Command Pattern is not going to get you a promotion at work or make you a 10x developer. What I believe is a better approach is to think of it in terms of knowing these patterns is not going to make you a worse developer.</p>
<p>I recently read a review of an album I like. In the review, the author said something along the lines of &ldquo;it is clear that this band knows all the rules of music, and are deliberately breaking them.&rdquo; In many ways, I think of design patterns as the &ldquo;rules of development&rdquo;. If you know them, you can decide when they should be deployed. Likewise, you also know their limitations or when no one rule will suffice. Again, this won&rsquo;t necessarily make you a better developer, but I am confident that this knowledge will not make you worse.</p>

    
  </div>

  

  
  

<div class="single-pagination">
    <hr />

    <div class="flex">

        <div class="single-pagination-prev">
            
            <div class="single-pagination-container-prev">
                <div class="single-pagination-text">←</div>
                <div class="single-pagination-text">
                    <a href="/posts/go-channel-usage/">
                        Go channel usage
                    </a>
                </div>
            </div>
            
        </div>

        <div class="single-pagination-next">
            
            <div class="single-pagination-container-next">
                <div class="single-pagination-text">
                    <a href="/posts/aws-certification/">
                        Aws Certifications
                    </a>
                </div>
                <div class="single-pagination-text">→</div>
            </div>
            
        </div>

    </div>

    <hr />
</div>



  

  

  
  <div class="back-to-top">
    <a href="#top">
      back to top
    </a>
  </div>
  

</div>


      </main>
    </div>

    <footer>
      <p>Powered by
    <a href="https://gohugo.io/">Hugo</a>
    and
    <a href="https://github.com/tomfran/typo">tomfran/typo</a>
</p>


    </footer>

  </body>

  <script>

  function isAuto() {
    return document.body.classList.contains("auto");
  }

  function setTheme() {
    if (!isAuto()) {
      return
    }

    document.body.classList.remove("auto");
    let cls = "light";
    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
      cls = "dark";
    }

    document.body.classList.add(cls);
  }

  function invertBody() {
    document.body.classList.toggle("dark");
    document.body.classList.toggle("light");
  }

  if (isAuto()) {
    window.matchMedia('(prefers-color-scheme: dark)').addListener(invertBody);
  }

  setTheme();

</script>

</html>